CCS PCH C Compiler, Version 5.015, 5967               23-abr.-24 22:55

               Filename:   C:\Users\Alfred\Documents\CCS C Projects\Practica_2.lst

               ROM used:   2748 bytes (8%)
                           Largest free fragment is 30020
               RAM used:   204 (10%) at main() level
                           239 (12%) worst case
               Stack used: 10 locations
               Stack size: 31

*
0000:  GOTO   08F6
.................... #include <18f4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
0004:  CLRF   FF7
0006:  ADDLW  14
0008:  MOVWF  FF6
000A:  MOVLW  00
000C:  ADDWFC FF7,F
000E:  TBLRD*+
0010:  MOVF   FF5,W
0012:  RETURN 0
0014:  DATA 31,32
0016:  DATA 33,41
0018:  DATA 34,35
001A:  DATA 36,42
001C:  DATA 37,38
001E:  DATA 39,43
0020:  DATA 2A,30
0022:  DATA 23,44
0024:  DATA 0C,00
0026:  DATA 0C,00
0028:  DATA 50,55
002A:  DATA 45,52
002C:  DATA 54,41
002E:  DATA 20,31
0030:  DATA 29,43
0032:  DATA 41,4D
0034:  DATA 42,49
0036:  DATA 41,52
0038:  DATA 0A,00
003A:  DATA 41,42
003C:  DATA 49,45
003E:  DATA 52,54
0040:  DATA 41,20
0042:  DATA 32,29
0044:  DATA 43,45
0046:  DATA 52,52
0048:  DATA 41,52
004A:  DATA 00,00
004C:  DATA 50,55
004E:  DATA 45,52
0050:  DATA 54,41
0052:  DATA 20,31
0054:  DATA 29,43
0056:  DATA 41,4D
0058:  DATA 42,49
005A:  DATA 41,52
005C:  DATA 0A,00
005E:  DATA 41,42
0060:  DATA 49,45
0062:  DATA 52,54
0064:  DATA 41,20
0066:  DATA 32,29
0068:  DATA 43,45
006A:  DATA 52,52
006C:  DATA 41,52
006E:  DATA 00,00
0070:  DATA 0C,00
0072:  DATA 0C,00
0074:  DATA 08,20
0076:  DATA 08,00
0078:  DATA 0C,00
007A:  DATA 0C,00
007C:  DATA 49,4E
007E:  DATA 54,45
0080:  DATA 4E,54
0082:  DATA 45,20
0084:  DATA 45,4E
0086:  DATA 20,3A
0088:  DATA 00,00
008A:  DATA 08,20
008C:  DATA 08,08
008E:  DATA 20,08
0090:  DATA 00,00
0092:  DATA 0C,00
0094:  DATA 43,4C
0096:  DATA 41,56
0098:  DATA 45,20
009A:  DATA 3A,20
009C:  DATA 00,00
009E:  DATA 08,20
00A0:  DATA 08,00
00A2:  DATA 0C,00
00A4:  DATA 0C,00
00A6:  DATA 0C,00
00A8:  DATA 49,4E
00AA:  DATA 49,43
00AC:  DATA 49,41
00AE:  DATA 4E,44
00B0:  DATA 4F,00
00B2:  DATA 0C,00
00B4:  DATA 08,20
00B6:  DATA 08,00
00B8:  DATA 08,20
00BA:  DATA 08,00
*
028A:  TBLRD*+
028C:  MOVF   FF5,F
028E:  BZ    02A8
0290:  MOVFF  FF6,E3
0294:  MOVFF  FF7,E4
0298:  MOVFF  FF5,E5
029C:  RCALL  023A
029E:  MOVFF  E3,FF6
02A2:  MOVFF  E4,FF7
02A6:  BRA    028A
02A8:  RETURN 0
*
033C:  MOVF   FEF,F
033E:  BZ    035E
0340:  MOVFF  FEA,E2
0344:  MOVFF  FE9,E1
0348:  MOVFF  FEF,E5
034C:  RCALL  023A
034E:  MOVFF  E2,FEA
0352:  MOVFF  E1,FE9
0356:  INCF   FE9,F
0358:  BTFSC  FD8.2
035A:  INCF   FEA,F
035C:  BRA    033C
035E:  RETURN 0
*
06D2:  MOVF   xDD,W
06D4:  CLRF   01
06D6:  SUBWF  xDC,W
06D8:  BC    06E0
06DA:  MOVFF  DC,00
06DE:  BRA    06F8
06E0:  CLRF   00
06E2:  MOVLW  08
06E4:  MOVWF  xDE
06E6:  RLCF   xDC,F
06E8:  RLCF   00,F
06EA:  MOVF   xDD,W
06EC:  SUBWF  00,W
06EE:  BTFSC  FD8.0
06F0:  MOVWF  00
06F2:  RLCF   01,F
06F4:  DECFSZ xDE,F
06F6:  BRA    06E6
06F8:  RETURN 0
....................  
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0510:  MOVFF  DA,FE9
0514:  MOVFF  DB,FEA
0518:  MOVFF  FEF,DE
051C:  MOVFF  DD,03
0520:  MOVFF  DC,FE9
0524:  MOVFF  DD,FEA
0528:  MOVF   FEF,W
052A:  SUBWF  xDE,W
052C:  BNZ   0558
....................       if (*s1 == '\0') 
052E:  MOVFF  DB,03
0532:  MOVFF  DA,FE9
0536:  MOVFF  03,FEA
053A:  MOVF   FEF,F
053C:  BNZ   0544
....................          return(0); 
053E:  MOVLW  00
0540:  MOVWF  01
0542:  BRA    0582
0544:  MOVFF  DB,03
0548:  MOVF   xDA,W
054A:  INCF   xDA,F
054C:  BTFSC  FD8.2
054E:  INCF   xDB,F
0550:  INCF   xDC,F
0552:  BTFSC  FD8.2
0554:  INCF   xDD,F
0556:  BRA    0510
....................    return((*s1 < *s2) ? -1: 1); 
0558:  MOVFF  DB,03
055C:  MOVFF  DA,FE9
0560:  MOVFF  DB,FEA
0564:  MOVFF  FEF,DE
0568:  MOVFF  DD,03
056C:  MOVFF  DC,FE9
0570:  MOVFF  DD,FEA
0574:  MOVF   FEF,W
0576:  SUBWF  xDE,W
0578:  BC    057E
057A:  MOVLW  FF
057C:  BRA    0580
057E:  MOVLW  01
0580:  MOVWF  01
0582:  RETURN 0
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #fuses xt, nowdt, intrc 
.................... #use delay(internal = 8M) 
*
00DC:  CLRF   FEA
00DE:  MOVLW  E6
00E0:  MOVWF  FE9
00E2:  MOVF   FEF,W
00E4:  BZ    0100
00E6:  MOVLW  02
00E8:  MOVWF  01
00EA:  CLRF   00
00EC:  DECFSZ 00,F
00EE:  BRA    00EC
00F0:  DECFSZ 01,F
00F2:  BRA    00EA
00F4:  MOVLW  97
00F6:  MOVWF  00
00F8:  DECFSZ 00,F
00FA:  BRA    00F8
00FC:  DECFSZ FEF,F
00FE:  BRA    00E6
0100:  RETURN 0
.................... #define LCD_DATA_PORT getenv("SFR:PORTD")    
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
0128:  MOVLW  0F
012A:  ANDWF  F95,W
012C:  IORLW  F0
012E:  MOVWF  F95
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0130:  BSF    F8C.2
....................    delay_cycles(1); 
0132:  NOP   
....................    lcd_output_enable(1); 
0134:  BSF    F8C.0
....................    delay_cycles(1); 
0136:  NOP   
....................    high = lcd_read_nibble(); 
0138:  RCALL  011C
013A:  MOVFF  01,ED
....................        
....................    lcd_output_enable(0); 
013E:  BCF    F8C.0
....................    delay_cycles(1); 
0140:  NOP   
....................    lcd_output_enable(1); 
0142:  BSF    F8C.0
....................    delay_us(1); 
0144:  BRA    0146
....................    low = lcd_read_nibble(); 
0146:  RCALL  011C
0148:  MOVFF  01,EC
....................        
....................    lcd_output_enable(0); 
014C:  BCF    F8C.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
014E:  MOVLW  0F
0150:  ANDWF  F95,W
0152:  MOVWF  F95
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0154:  SWAPF  xED,W
0156:  MOVWF  00
0158:  MOVLW  F0
015A:  ANDWF  00,F
015C:  MOVF   00,W
015E:  IORWF  xEC,W
0160:  MOVWF  01
0162:  GOTO   0170 (RETURN)
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
011C:  MOVF   F83,W
011E:  MOVWF  00
0120:  SWAPF  00,W
0122:  ANDLW  0F
0124:  MOVWF  01
....................   #endif 
0126:  RETURN 0
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
0102:  SWAPF  xED,W
0104:  ANDLW  F0
0106:  MOVWF  00
0108:  MOVLW  0F
010A:  ANDWF  F8C,W
010C:  IORWF  00,W
010E:  MOVWF  F8C
....................   #endif 
....................        
....................    delay_cycles(1); 
0110:  NOP   
....................    lcd_output_enable(1); 
0112:  BSF    F8C.0
....................    delay_us(2); 
0114:  BRA    0116
0116:  BRA    0118
....................    lcd_output_enable(0); 
0118:  BCF    F8C.0
011A:  RETURN 0
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0166:  BCF    F95.0
....................    lcd_rs_tris(); 
0168:  BCF    F95.1
....................    lcd_rw_tris(); 
016A:  BCF    F95.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
016C:  BCF    F8C.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
016E:  BRA    0128
0170:  MOVFF  01,EC
0174:  BTFSC  01.7
0176:  BRA    016E
....................    lcd_output_rs(address); 
0178:  BCF    F8C.1
017A:  BTFSC  xEA.0
017C:  BSF    F8C.1
....................    delay_cycles(1); 
017E:  NOP   
....................    lcd_output_rw(0); 
0180:  BCF    F8C.2
....................    delay_cycles(1); 
0182:  NOP   
....................    lcd_output_enable(0); 
0184:  BCF    F8C.0
....................    lcd_send_nibble(n >> 4); 
0186:  SWAPF  xEB,W
0188:  MOVWF  xEC
018A:  MOVLW  0F
018C:  ANDWF  xEC,F
018E:  MOVFF  EC,ED
0192:  RCALL  0102
....................    lcd_send_nibble(n & 0xf); 
0194:  MOVF   xEB,W
0196:  ANDLW  0F
0198:  MOVWF  xEC
019A:  MOVWF  xED
019C:  RCALL  0102
019E:  RETURN 0
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
01A0:  MOVLW  28
01A2:  MOVWF  xCF
01A4:  MOVLW  0C
01A6:  MOVWF  xD0
01A8:  MOVLW  01
01AA:  MOVWF  xD1
01AC:  MOVLW  06
01AE:  MOVWF  xD2
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
01B0:  BCF    F8C.0
....................    lcd_output_rs(0); 
01B2:  BCF    F8C.1
....................    lcd_output_rw(0); 
01B4:  BCF    F8C.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
01B6:  MOVLW  0F
01B8:  ANDWF  F95,W
01BA:  MOVWF  F95
....................   #endif 
....................    lcd_enable_tris(); 
01BC:  BCF    F95.0
....................    lcd_rs_tris(); 
01BE:  BCF    F95.1
....................    lcd_rw_tris(); 
01C0:  BCF    F95.2
....................  #endif 
....................      
....................    delay_ms(15); 
01C2:  MOVLW  0F
01C4:  MOVWF  xE6
01C6:  RCALL  00DC
....................    for(i=1;i<=3;++i) 
01C8:  MOVLW  01
01CA:  MOVWF  xCE
01CC:  MOVF   xCE,W
01CE:  SUBLW  03
01D0:  BNC   01E2
....................    { 
....................        lcd_send_nibble(3); 
01D2:  MOVLW  03
01D4:  MOVWF  xED
01D6:  RCALL  0102
....................        delay_ms(5); 
01D8:  MOVLW  05
01DA:  MOVWF  xE6
01DC:  RCALL  00DC
01DE:  INCF   xCE,F
01E0:  BRA    01CC
....................    } 
....................     
....................    lcd_send_nibble(2); 
01E2:  MOVLW  02
01E4:  MOVWF  xED
01E6:  RCALL  0102
....................    delay_ms(5); 
01E8:  MOVLW  05
01EA:  MOVWF  xE6
01EC:  RCALL  00DC
....................    for(i=0;i<=3;++i) 
01EE:  CLRF   xCE
01F0:  MOVF   xCE,W
01F2:  SUBLW  03
01F4:  BNC   0214
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
01F6:  CLRF   03
01F8:  MOVF   xCE,W
01FA:  ADDLW  CF
01FC:  MOVWF  FE9
01FE:  MOVLW  00
0200:  ADDWFC 03,W
0202:  MOVWF  FEA
0204:  MOVFF  FEF,D3
0208:  CLRF   xEA
020A:  MOVFF  D3,EB
020E:  RCALL  0166
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0210:  INCF   xCE,F
0212:  BRA    01F0
0214:  GOTO   02AC (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
0218:  DECFSZ xE7,W
021A:  BRA    021E
021C:  BRA    0224
....................       address=LCD_LINE_TWO; 
021E:  MOVLW  40
0220:  MOVWF  xE8
0222:  BRA    0226
....................    else 
....................       address=0; 
0224:  CLRF   xE8
....................       
....................    address+=x-1; 
0226:  MOVLW  01
0228:  SUBWF  xE6,W
022A:  ADDWF  xE8,F
....................    lcd_send_byte(0,0x80|address); 
022C:  MOVF   xE8,W
022E:  IORLW  80
0230:  MOVWF  xE9
0232:  CLRF   xEA
0234:  MOVWF  xEB
0236:  RCALL  0166
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0238:  RETURN 0
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
023A:  MOVF   xE5,W
023C:  XORLW  07
023E:  BZ    024E
0240:  XORLW  0B
0242:  BZ    0258
0244:  XORLW  06
0246:  BZ    0268
0248:  XORLW  02
024A:  BZ    0274
024C:  BRA    027E
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
024E:  MOVLW  01
0250:  MOVWF  xE6
0252:  MOVWF  xE7
0254:  RCALL  0218
0256:  BRA    0288
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0258:  CLRF   xEA
025A:  MOVLW  01
025C:  MOVWF  xEB
025E:  RCALL  0166
....................                      delay_ms(2); 
0260:  MOVLW  02
0262:  MOVWF  xE6
0264:  RCALL  00DC
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0266:  BRA    0288
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0268:  MOVLW  01
026A:  MOVWF  xE6
026C:  MOVLW  02
026E:  MOVWF  xE7
0270:  RCALL  0218
0272:  BRA    0288
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0274:  CLRF   xEA
0276:  MOVLW  10
0278:  MOVWF  xEB
027A:  RCALL  0166
027C:  BRA    0288
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
027E:  MOVLW  01
0280:  MOVWF  xEA
0282:  MOVFF  E5,EB
0286:  RCALL  0166
....................      #endif 
....................    } 
0288:  RETURN 0
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #byte TRISB = 0xF93 
.................... #byte PORTB = 0xF81 
.................... #byte TRISC = 0xF94 
.................... #byte PORTC = 0xF82 
....................  
.................... #define VERDE        0 
.................... #define AMARILLA     1 
.................... #define ROJA         2 
.................... #define APAGADO      0 
.................... #define ENCENDIDO    1 
.................... #define MAX_LONGITUD 5 
....................  
.................... char *mensages[] = { 
....................         "CLAVE\n   INCORRECTA", 
....................         "ABRIENDO\n      PUERTA", 
....................         "CERRANDO\n      PUERTA", 
....................         "NUEVA CLAVE", 
....................         "CONFIRMAR CLAVE", 
....................         "CLAVE\n   ACTUALIZADA", 
....................         "PUERTA CERRADA", 
....................         " CLAVE ACTUAL", 
....................         "LAS CLAVES\n   NO COINCIDEN" 
....................     }; 
....................  
.................... void cargando(); 
.................... void mensage_info(char cadena[], int pos_x, int pos_y, int tipo, int establecer); 
.................... char com_tecla(); 
.................... int comando_tecla(); 
.................... void ingresar_clave(char clave[], char cadena[]); 
.................... void esperar(int tiempo); 
.................... void acceso_permitido(char cadena[]); 
.................... void inicializar(char cadena[], int longitud, char valor); 
.................... int cambiar_clave(); 
.................... void obtener_nueva_clave(char clave[], char mensaje[]); 
.................... void imprimir_cadena(char cadena[]); 
....................  
.................... char clave[MAX_LONGITUD] = {'1','2','3','4','\0'}; 
....................  
.................... void main() 
*
08F6:  CLRF   FF8
08F8:  BCF    FD0.7
08FA:  MOVLW  70
08FC:  MOVWF  FD3
08FE:  MOVF   FD3,W
0900:  MOVF   FC1,W
0902:  ANDLW  C0
0904:  IORLW  0F
0906:  MOVWF  FC1
0908:  MOVLW  07
090A:  MOVWF  FB4
090C:  BRA    09DC
090E:  DATA 02,00
0910:  DATA 04,00
0912:  DATA 00,1D
0914:  DATA 00,18
0916:  DATA 43,4C
0918:  DATA 41,56
091A:  DATA 45,0A
091C:  DATA 20,20
091E:  DATA 20,49
0920:  DATA 4E,43
0922:  DATA 4F,52
0924:  DATA 52,45
0926:  DATA 43,54
0928:  DATA 41,00
092A:  DATA 41,42
092C:  DATA 52,49
092E:  DATA 45,4E
0930:  DATA 44,4F
0932:  DATA 0A,06
0934:  DATA C0,20
0936:  DATA 10,80
0938:  DATA 50,55
093A:  DATA 45,52
093C:  DATA 54,41
093E:  DATA 00,43
0940:  DATA 45,52
0942:  DATA 52,41
0944:  DATA 4E,44
0946:  DATA 4F,0A
0948:  DATA 06,C0
094A:  DATA 20,70
094C:  DATA 80,50
094E:  DATA 55,45
0950:  DATA 52,54
0952:  DATA 41,00
0954:  DATA 4E,55
0956:  DATA 45,56
0958:  DATA 41,20
095A:  DATA 43,4C
095C:  DATA 41,56
095E:  DATA 45,00
0960:  DATA 43,4F
0962:  DATA 4E,46
0964:  DATA 49,52
0966:  DATA 4D,41
0968:  DATA 52,20
096A:  DATA 43,4C
096C:  DATA 41,56
096E:  DATA 45,00
0970:  DATA 43,4C
0972:  DATA 41,56
0974:  DATA 45,0A
0976:  DATA 20,20
0978:  DATA 20,41
097A:  DATA 43,54
097C:  DATA 55,41
097E:  DATA 4C,49
0980:  DATA 5A,41
0982:  DATA 44,41
0984:  DATA 00,50
0986:  DATA 55,45
0988:  DATA 52,54
098A:  DATA 41,20
098C:  DATA 43,45
098E:  DATA 52,52
0990:  DATA 41,44
0992:  DATA 41,00
0994:  DATA 20,43
0996:  DATA 4C,41
0998:  DATA 56,45
099A:  DATA 20,41
099C:  DATA 43,54
099E:  DATA 55,41
09A0:  DATA 4C,00
09A2:  DATA 4C,41
09A4:  DATA 53,20
09A6:  DATA 43,4C
09A8:  DATA 41,56
09AA:  DATA 45,53
09AC:  DATA 0A,20
09AE:  DATA 20,20
09B0:  DATA 4E,4F
09B2:  DATA 20,43
09B4:  DATA 4F,49
09B6:  DATA 4E,43
09B8:  DATA 49,44
09BA:  DATA 45,4E
09BC:  DATA 00,12
09BE:  DATA 00,06
09C0:  DATA 18,00
09C2:  DATA 2C,00
09C4:  DATA 42,00
09C6:  DATA 58,00
09C8:  DATA 64,00
09CA:  DATA 74,00
09CC:  DATA 89,00
09CE:  DATA 98,00
09D0:  DATA A6,00
09D2:  DATA 05,00
09D4:  DATA C1,31
09D6:  DATA 32,33
09D8:  DATA 34,00
09DA:  DATA 00,00
09DC:  MOVLW  00
09DE:  MOVWF  FF8
09E0:  MOVLW  09
09E2:  MOVWF  FF7
09E4:  MOVLW  0E
09E6:  MOVWF  FF6
09E8:  TBLRD*+
09EA:  MOVF   FF5,W
09EC:  MOVWF  00
09EE:  XORLW  00
09F0:  BZ    0A18
09F2:  TBLRD*+
09F4:  MOVF   FF5,W
09F6:  MOVWF  01
09F8:  BTFSC  FE8.7
09FA:  BRA    0A06
09FC:  ANDLW  0F
09FE:  MOVWF  FEA
0A00:  TBLRD*+
0A02:  MOVFF  FF5,FE9
0A06:  BTFSC  01.6
0A08:  TBLRD*+
0A0A:  BTFSS  01.6
0A0C:  TBLRD*+
0A0E:  MOVFF  FF5,FEE
0A12:  DCFSNZ 00,F
0A14:  BRA    09E8
0A16:  BRA    0A0A
0A18:  CLRF   FF8
0A1A:  CLRF   xC6
.................... { 
....................    int intentos_ingresar = 0; 
....................    char clave_ingresada[MAX_LONGITUD]; 
....................    TRISC = 0x00; 
0A1C:  CLRF   F94
....................    PORTC = 0x00; 
0A1E:  CLRF   F82
....................    inicializar(clave_ingresada, MAX_LONGITUD, '\0'); 
0A20:  CLRF   xDB
0A22:  MOVLW  C7
0A24:  MOVWF  xDA
0A26:  MOVLW  05
0A28:  MOVWF  xDC
0A2A:  CLRF   xDD
0A2C:  CALL   00BC
....................     
....................    cargando(); 
0A30:  BRA    02AA
....................  
....................    while(TRUE) 
....................    { 
....................       ingresar_clave(clave_ingresada, mensages[6]); 
0A32:  CLRF   xDB
0A34:  MOVLW  C7
0A36:  MOVWF  xDA
0A38:  MOVFF  13,DD
0A3C:  MOVFF  12,DC
0A40:  RCALL  0466
....................       if(!strcmp(clave, clave_ingresada)) 
0A42:  CLRF   xDB
0A44:  MOVLW  C1
0A46:  MOVWF  xDA
0A48:  CLRF   xDD
0A4A:  MOVLW  C7
0A4C:  MOVWF  xDC
0A4E:  RCALL  0510
0A50:  MOVF   01,F
0A52:  BNZ   0A84
....................       { 
....................          lcd_putc("\f");  
0A54:  MOVLW  24
0A56:  MOVWF  FF6
0A58:  MOVLW  00
0A5A:  MOVWF  FF7
0A5C:  RCALL  028A
....................          mensage_info(mensages[1], 6, 1, AMARILLA, APAGADO); 
0A5E:  MOVFF  09,DB
0A62:  MOVFF  08,DA
0A66:  MOVLW  06
0A68:  MOVWF  xDC
0A6A:  MOVLW  01
0A6C:  MOVWF  xDD
0A6E:  MOVWF  xDE
0A70:  CLRF   xDF
0A72:  RCALL  0584
....................          bit_set(PORTC, 0); 
0A74:  BSF    F82.0
....................          acceso_permitido(mensages[2]); 
0A76:  MOVFF  0B,CD
0A7A:  MOVFF  0A,CC
0A7E:  BRA    088A
....................          intentos_ingresar = 0; 
0A80:  CLRF   xC6
....................       }else 
0A82:  BRA    0AAC
....................       { 
....................          mensage_info(mensages[0], 7, 1, ROJA, APAGADO); 
0A84:  MOVFF  07,DB
0A88:  MOVFF  06,DA
0A8C:  MOVLW  07
0A8E:  MOVWF  xDC
0A90:  MOVLW  01
0A92:  MOVWF  xDD
0A94:  MOVLW  02
0A96:  MOVWF  xDE
0A98:  CLRF   xDF
0A9A:  RCALL  0584
....................          if(++intentos_ingresar == 2) 
0A9C:  INCF   xC6,F
0A9E:  MOVF   xC6,W
0AA0:  SUBLW  02
0AA2:  BNZ   0AAC
....................          { 
....................             esperar(20); 
0AA4:  MOVLW  14
0AA6:  MOVWF  xDA
0AA8:  RCALL  06FA
....................             intentos_ingresar = 0; 
0AAA:  CLRF   xC6
....................          } 
....................       } 
....................       lcd_putc("\f"); 
0AAC:  MOVLW  26
0AAE:  MOVWF  FF6
0AB0:  MOVLW  00
0AB2:  MOVWF  FF7
0AB4:  CALL   028A
0AB8:  BRA    0A32
....................    }    
.................... } 
....................  
0ABA:  SLEEP 
....................  
.................... ////********Si la clave es correcta 
....................  
.................... //permance mientras este dentro(puerta abierta) 
.................... void acceso_permitido(char cadena[]) 
*
088A:  CLRF   xCE
.................... { 
....................    char tecla = 0;  
....................    lcd_putc("PUERTA 1)CAMBIAR\n");  
088C:  MOVLW  28
088E:  MOVWF  FF6
0890:  MOVLW  00
0892:  MOVWF  FF7
0894:  RCALL  028A
....................    lcd_putc("ABIERTA 2)CERRAR"); 
0896:  MOVLW  3A
0898:  MOVWF  FF6
089A:  MOVLW  00
089C:  MOVWF  FF7
089E:  RCALL  028A
....................    do 
....................    { 
....................       tecla = com_tecla(); 
08A0:  RCALL  0360
08A2:  MOVFF  01,CE
....................       switch(tecla) 
08A6:  MOVF   xCE,W
08A8:  XORLW  31
08AA:  BZ    08B2
08AC:  XORLW  03
08AE:  BZ    08CA
08B0:  BRA    08EC
....................       { 
....................          case '1': 
....................              
....................             cambiar_clave(); 
08B2:  BRA    0776
.................... //!            lcd_gotoxy(2, 1); 
.................... //!            lcd_putc("PUERTA ABIERTA");  
.................... //!            lcd_gotoxy(1, 2); 
.................... //!            lcd_putc("1)CAMBIA 2)SALIR"); 
....................             lcd_putc("PUERTA 1)CAMBIAR\n");  
08B4:  MOVLW  4C
08B6:  MOVWF  FF6
08B8:  MOVLW  00
08BA:  MOVWF  FF7
08BC:  RCALL  028A
....................             lcd_putc("ABIERTA 2)CERRAR"); 
08BE:  MOVLW  5E
08C0:  MOVWF  FF6
08C2:  MOVLW  00
08C4:  MOVWF  FF7
08C6:  RCALL  028A
....................             break; 
08C8:  BRA    08EC
....................          case '2': 
....................             lcd_putc("\f"); 
08CA:  MOVLW  70
08CC:  MOVWF  FF6
08CE:  MOVLW  00
08D0:  MOVWF  FF7
08D2:  RCALL  028A
....................             bit_clear(PORTC, 0); 
08D4:  BCF    F82.0
....................             mensage_info(cadena, 6, 1, AMARILLA, APAGADO); 
08D6:  MOVFF  CD,DB
08DA:  MOVFF  CC,DA
08DE:  MOVLW  06
08E0:  MOVWF  xDC
08E2:  MOVLW  01
08E4:  MOVWF  xDD
08E6:  MOVWF  xDE
08E8:  CLRF   xDF
08EA:  RCALL  0584
....................             break; 
....................       } 
....................    }while(tecla != '2'); 
08EC:  MOVF   xCE,W
08EE:  SUBLW  32
08F0:  BNZ   08A0
08F2:  GOTO   0A80 (RETURN)
.................... } 
....................  
.................... int cambiar_clave() 
.................... { 
....................    char clave_ingresada[MAX_LONGITUD]; 
....................      
....................    inicializar(clave_ingresada, MAX_LONGITUD, '\0'); 
*
0776:  CLRF   xDB
0778:  MOVLW  CF
077A:  MOVWF  xDA
077C:  MOVLW  05
077E:  MOVWF  xDC
0780:  CLRF   xDD
0782:  RCALL  00BC
....................    lcd_putc("\f"); 
0784:  MOVLW  72
0786:  MOVWF  FF6
0788:  MOVLW  00
078A:  MOVWF  FF7
078C:  RCALL  028A
....................    for(int intentos_autenticar = 0; intentos_autenticar < 2; intentos_autenticar++) 
078E:  CLRF   xD4
0790:  MOVF   xD4,W
0792:  SUBLW  01
0794:  BTFSS  FD8.0
0796:  BRA    087C
....................    { 
....................       ingresar_clave(clave_ingresada, mensages[7]); 
0798:  CLRF   xDB
079A:  MOVLW  CF
079C:  MOVWF  xDA
079E:  MOVFF  15,DD
07A2:  MOVFF  14,DC
07A6:  RCALL  0466
....................     
....................       if(!strcmp(clave, clave_ingresada)) 
07A8:  CLRF   xDB
07AA:  MOVLW  C1
07AC:  MOVWF  xDA
07AE:  CLRF   xDD
07B0:  MOVLW  CF
07B2:  MOVWF  xDC
07B4:  RCALL  0510
07B6:  MOVF   01,F
07B8:  BNZ   0860
....................       { 
....................          char clave_verificar[MAX_LONGITUD]; 
....................          for(intentos_autenticar = 0; intentos_autenticar < 2; intentos_autenticar++) 
07BA:  CLRF   xD4
07BC:  MOVF   xD4,W
07BE:  SUBLW  01
07C0:  BNC   085E
....................          {                         
....................             inicializar(clave_ingresada, MAX_LONGITUD, '\0'); 
07C2:  CLRF   xDB
07C4:  MOVLW  CF
07C6:  MOVWF  xDA
07C8:  MOVLW  05
07CA:  MOVWF  xDC
07CC:  CLRF   xDD
07CE:  RCALL  00BC
....................             inicializar(clave_verificar, MAX_LONGITUD, '\0'); 
07D0:  CLRF   xDB
07D2:  MOVLW  D5
07D4:  MOVWF  xDA
07D6:  MOVLW  05
07D8:  MOVWF  xDC
07DA:  CLRF   xDD
07DC:  RCALL  00BC
....................              
....................             obtener_nueva_clave(clave_ingresada, mensages[3]); 
07DE:  CLRF   xDB
07E0:  MOVLW  CF
07E2:  MOVWF  xDA
07E4:  MOVFF  0D,DD
07E8:  MOVFF  0C,DC
07EC:  RCALL  0632
....................             obtener_nueva_clave(clave_verificar,mensages[4]); 
07EE:  CLRF   xDB
07F0:  MOVLW  D5
07F2:  MOVWF  xDA
07F4:  MOVFF  0F,DD
07F8:  MOVFF  0E,DC
07FC:  RCALL  0632
....................              
....................             if(!strcmp(clave_ingresada, clave_verificar)) 
07FE:  CLRF   xDB
0800:  MOVLW  CF
0802:  MOVWF  xDA
0804:  CLRF   xDD
0806:  MOVLW  D5
0808:  MOVWF  xDC
080A:  RCALL  0510
080C:  MOVF   01,F
080E:  BNZ   0842
....................             { 
....................                strcpy(clave, clave_verificar); 
0810:  CLRF   FEA
0812:  MOVLW  C1
0814:  MOVWF  FE9
0816:  CLRF   FE2
0818:  MOVLW  D5
081A:  MOVWF  FE1
081C:  MOVF   FE7,F
081E:  MOVFF  FE6,FEE
0822:  BNZ   081C
....................                mensage_info(mensages[5], 7, 1, VERDE, ENCENDIDO); 
0824:  MOVFF  11,DB
0828:  MOVFF  10,DA
082C:  MOVLW  07
082E:  MOVWF  xDC
0830:  MOVLW  01
0832:  MOVWF  xDD
0834:  CLRF   xDE
0836:  MOVWF  xDF
0838:  RCALL  0584
....................                return 0; 
083A:  MOVLW  00
083C:  MOVWF  01
083E:  BRA    0886
....................             }else 
0840:  BRA    085A
....................             { 
....................                mensage_info(mensages[8], 7, 1, ROJA, APAGADO); 
0842:  MOVFF  17,DB
0846:  MOVFF  16,DA
084A:  MOVLW  07
084C:  MOVWF  xDC
084E:  MOVLW  01
0850:  MOVWF  xDD
0852:  MOVLW  02
0854:  MOVWF  xDE
0856:  CLRF   xDF
0858:  RCALL  0584
....................             } 
085A:  INCF   xD4,F
085C:  BRA    07BC
....................          }          
....................       }else 
085E:  BRA    0878
....................       { 
....................          mensage_info(mensages[0], 7, 1, ROJA, APAGADO); 
0860:  MOVFF  07,DB
0864:  MOVFF  06,DA
0868:  MOVLW  07
086A:  MOVWF  xDC
086C:  MOVLW  01
086E:  MOVWF  xDD
0870:  MOVLW  02
0872:  MOVWF  xDE
0874:  CLRF   xDF
0876:  RCALL  0584
....................       } 
0878:  INCF   xD4,F
087A:  BRA    0790
....................    } 
....................    esperar(10); 
087C:  MOVLW  0A
087E:  MOVWF  xDA
0880:  RCALL  06FA
....................    return 1; 
0882:  MOVLW  01
0884:  MOVWF  01
0886:  GOTO   08B4 (RETURN)
.................... } 
....................  
....................  
....................  
.................... //espera la nueva clave debe tener 4 digitos para retornar la clave 
.................... void obtener_nueva_clave(char clave[], char mensaje[]) 
*
0632:  CLRF   xDE
0634:  CLRF   xDF
.................... { 
....................    int longitud = 0; 
....................    char tecla = 0;  
....................    lcd_gotoxy(2,1); 
0636:  MOVLW  02
0638:  MOVWF  xE6
063A:  MOVLW  01
063C:  MOVWF  xE7
063E:  RCALL  0218
....................    printf(lcd_putc,"%s", mensaje); 
0640:  MOVFF  DD,FEA
0644:  MOVFF  DC,FE9
0648:  RCALL  033C
....................    
....................    lcd_gotoxy(6,2); 
064A:  MOVLW  06
064C:  MOVWF  xE6
064E:  MOVLW  02
0650:  MOVWF  xE7
0652:  RCALL  0218
....................    do 
....................    { 
....................       tecla = comando_tecla(); 
0654:  RCALL  0402
0656:  MOVFF  01,DF
....................       if(longitud < MAX_LONGITUD - 1) 
065A:  MOVF   xDE,W
065C:  SUBLW  03
065E:  BNC   0686
....................       { 
....................          if(tecla >= '0' && tecla <= '9') 
0660:  MOVF   xDF,W
0662:  SUBLW  2F
0664:  BC    0686
0666:  MOVF   xDF,W
0668:  SUBLW  39
066A:  BNC   0686
....................          { 
....................             //lcd_gotoxy(11 + longitud,2); 
....................             lcd_putc('*'); 
066C:  MOVLW  2A
066E:  MOVWF  xE5
0670:  RCALL  023A
....................             clave[longitud++] = tecla; 
0672:  MOVF   xDE,W
0674:  INCF   xDE,F
0676:  CLRF   03
0678:  ADDWF  xDA,W
067A:  MOVWF  FE9
067C:  MOVF   xDB,W
067E:  ADDWFC 03,W
0680:  MOVWF  FEA
0682:  MOVFF  DF,FEF
....................          }        
....................       } 
....................       if(tecla == 'A' && longitud > 0) 
0686:  MOVF   xDF,W
0688:  SUBLW  41
068A:  BNZ   06AC
068C:  MOVF   xDE,F
068E:  BZ    06AC
....................       { 
....................          clave[longitud--] = '\0'; 
0690:  MOVF   xDE,W
0692:  DECF   xDE,F
0694:  CLRF   03
0696:  ADDWF  xDA,W
0698:  MOVWF  FE9
069A:  MOVF   xDB,W
069C:  ADDWFC 03,W
069E:  MOVWF  FEA
06A0:  CLRF   FEF
....................          lcd_putc("\b \b"); 
06A2:  MOVLW  74
06A4:  MOVWF  FF6
06A6:  MOVLW  00
06A8:  MOVWF  FF7
06AA:  RCALL  028A
....................       } 
....................    }while(tecla != 'D' || longitud != MAX_LONGITUD - 1); 
06AC:  MOVF   xDF,W
06AE:  SUBLW  44
06B0:  BNZ   0654
06B2:  MOVF   xDE,W
06B4:  SUBLW  04
06B6:  BNZ   0654
....................    clave[MAX_LONGITUD - 1] = '\0'; 
06B8:  MOVLW  04
06BA:  ADDWF  xDA,W
06BC:  MOVWF  FE9
06BE:  MOVLW  00
06C0:  ADDWFC xDB,W
06C2:  MOVWF  FEA
06C4:  CLRF   FEF
....................    lcd_putc("\f"); 
06C6:  MOVLW  78
06C8:  MOVWF  FF6
06CA:  MOVLW  00
06CC:  MOVWF  FF7
06CE:  RCALL  028A
06D0:  RETURN 0
.................... } 
....................  
....................  
.................... /** 
....................    bloquea el sistema entre 1 & 99seg 
....................    depende de el valor asignado 
.................... **/ 
.................... void esperar(int tiempo) 
.................... { 
....................    lcd_putc("\f");  
*
06FA:  MOVLW  7A
06FC:  MOVWF  FF6
06FE:  MOVLW  00
0700:  MOVWF  FF7
0702:  RCALL  028A
....................    bit_set(PORTC, 1); 
0704:  BSF    F82.1
....................    lcd_gotoxy(3,1); 
0706:  MOVLW  03
0708:  MOVWF  xE6
070A:  MOVLW  01
070C:  MOVWF  xE7
070E:  RCALL  0218
....................    lcd_putc("INTENTE EN :");  
0710:  MOVLW  7C
0712:  MOVWF  FF6
0714:  MOVLW  00
0716:  MOVWF  FF7
0718:  RCALL  028A
....................    lcd_gotoxy(8,2); 
071A:  MOVLW  08
071C:  MOVWF  xE6
071E:  MOVLW  02
0720:  MOVWF  xE7
0722:  RCALL  0218
....................    for(int i = tiempo; i > 0; i--) 
0724:  MOVFF  DA,DB
0728:  MOVF   xDB,F
072A:  BZ    0768
....................    {   
....................       lcd_putc((char)(48 + (i/10))); 
072C:  MOVFF  DB,DC
0730:  MOVLW  0A
0732:  MOVWF  xDD
0734:  RCALL  06D2
0736:  MOVF   01,W
0738:  ADDLW  30
073A:  MOVWF  xDC
073C:  MOVWF  xE5
073E:  RCALL  023A
....................       lcd_putc((char)(48 + (i%10)));  
0740:  MOVFF  DB,DC
0744:  MOVLW  0A
0746:  MOVWF  xDD
0748:  RCALL  06D2
074A:  MOVF   00,W
074C:  ADDLW  30
074E:  MOVWF  xDC
0750:  MOVWF  xE5
0752:  RCALL  023A
....................       delay_ms(250); 
0754:  MOVLW  FA
0756:  MOVWF  xE6
0758:  RCALL  00DC
....................       lcd_putc("\b \b\b \b"); 
075A:  MOVLW  8A
075C:  MOVWF  FF6
075E:  MOVLW  00
0760:  MOVWF  FF7
0762:  RCALL  028A
0764:  DECF   xDB,F
0766:  BRA    0728
....................    } 
....................    bit_clear(PORTC, 1); 
0768:  BCF    F82.1
....................    lcd_putc("\f");  
076A:  MOVLW  92
076C:  MOVWF  FF6
076E:  MOVLW  00
0770:  MOVWF  FF7
0772:  RCALL  028A
0774:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... // OKKKKKKK 
....................  
.................... /**  
....................    espera a que ingrese la clave 
....................    perimite valores de '0' a '9' 
....................    tecla 'A' para eliminar el ultimo caracter 
....................    tecla 'D' = OK para comprobar la clave 
.................... **/ 
.................... void ingresar_clave(char clave[], char cadena[]) 
.................... { 
....................    lcd_gotoxy(2,1); 
*
0466:  MOVLW  02
0468:  MOVWF  xE6
046A:  MOVLW  01
046C:  MOVWF  xE7
046E:  RCALL  0218
....................    printf(lcd_putc,"%s", cadena); 
0470:  MOVFF  DD,FEA
0474:  MOVFF  DC,FE9
0478:  RCALL  033C
....................    lcd_gotoxy(3,2); 
047A:  MOVLW  03
047C:  MOVWF  xE6
047E:  MOVLW  02
0480:  MOVWF  xE7
0482:  RCALL  0218
....................    lcd_putc("CLAVE : "); 
0484:  MOVLW  94
0486:  MOVWF  FF6
0488:  MOVLW  00
048A:  MOVWF  FF7
048C:  RCALL  028A
....................    int longitud = 0; 
....................    char tecla = 0;  
048E:  CLRF   xDE
0490:  CLRF   xDF
....................    do 
....................    { 
....................       tecla = comando_tecla(); 
0492:  RCALL  0402
0494:  MOVFF  01,DF
....................       if(longitud < MAX_LONGITUD - 1) 
0498:  MOVF   xDE,W
049A:  SUBLW  03
049C:  BNC   04D4
....................       { 
....................          if(tecla >= '0' && tecla <= '9') 
049E:  MOVF   xDF,W
04A0:  SUBLW  2F
04A2:  BC    04D4
04A4:  MOVF   xDF,W
04A6:  SUBLW  39
04A8:  BNC   04D4
....................          { 
....................             lcd_putc('*'); 
04AA:  MOVLW  2A
04AC:  MOVWF  xE5
04AE:  RCALL  023A
....................             clave[longitud++] = tecla; 
04B0:  MOVF   xDE,W
04B2:  INCF   xDE,F
04B4:  CLRF   03
04B6:  ADDWF  xDA,W
04B8:  MOVWF  FE9
04BA:  MOVF   xDB,W
04BC:  ADDWFC 03,W
04BE:  MOVWF  FEA
04C0:  MOVFF  DF,FEF
....................             clave[longitud] = '\0'; 
04C4:  CLRF   03
04C6:  MOVF   xDE,W
04C8:  ADDWF  xDA,W
04CA:  MOVWF  FE9
04CC:  MOVF   xDB,W
04CE:  ADDWFC 03,W
04D0:  MOVWF  FEA
04D2:  CLRF   FEF
....................          }        
....................       } 
....................       if(tecla == 'A' && longitud > 0) 
04D4:  MOVF   xDF,W
04D6:  SUBLW  41
04D8:  BNZ   04FA
04DA:  MOVF   xDE,F
04DC:  BZ    04FA
....................       { 
....................          clave[longitud--] = '\0'; 
04DE:  MOVF   xDE,W
04E0:  DECF   xDE,F
04E2:  CLRF   03
04E4:  ADDWF  xDA,W
04E6:  MOVWF  FE9
04E8:  MOVF   xDB,W
04EA:  ADDWFC 03,W
04EC:  MOVWF  FEA
04EE:  CLRF   FEF
....................          lcd_putc("\b \b"); 
04F0:  MOVLW  9E
04F2:  MOVWF  FF6
04F4:  MOVLW  00
04F6:  MOVWF  FF7
04F8:  RCALL  028A
....................       } 
....................        
....................    }while(tecla != 'D' || longitud == 0); 
04FA:  MOVF   xDF,W
04FC:  SUBLW  44
04FE:  BNZ   0492
0500:  MOVF   xDE,F
0502:  BZ    0492
....................    lcd_putc("\f"); 
0504:  MOVLW  A2
0506:  MOVWF  FF6
0508:  MOVLW  00
050A:  MOVWF  FF7
050C:  RCALL  028A
050E:  RETURN 0
.................... } 
....................  
.................... //muestra mensage informativo en el LCD en x,y 
.................... void mensage_info(char cadena[], int pos_x, int pos_y, int luz, int establecer) 
.................... { 
....................    for(int j = 1; j < 4; j++) 
*
0584:  MOVLW  01
0586:  MOVWF  xE0
0588:  MOVF   xE0,W
058A:  SUBLW  03
058C:  BNC   0606
....................    { 
....................       lcd_gotoxy(pos_x, pos_y); 
058E:  MOVFF  DC,E6
0592:  MOVFF  DD,E7
0596:  RCALL  0218
....................       printf(lcd_putc,"%s", cadena); 
0598:  MOVFF  DB,FEA
059C:  MOVFF  DA,FE9
05A0:  RCALL  033C
....................       if(luz == 0 || luz == 1 || luz == 2) 
05A2:  MOVF   xDE,F
05A4:  BZ    05B2
05A6:  DECFSZ xDE,W
05A8:  BRA    05AC
05AA:  BRA    05B2
05AC:  MOVF   xDE,W
05AE:  SUBLW  02
05B0:  BNZ   05F8
....................       { 
....................          bit_set(PORTC, luz); 
05B2:  MOVLW  01
05B4:  MOVWF  00
05B6:  MOVF   xDE,W
05B8:  MOVWF  01
05BA:  BZ    05C4
05BC:  BCF    FD8.0
05BE:  RLCF   00,F
05C0:  DECFSZ 01,F
05C2:  BRA    05BC
05C4:  MOVF   00,W
05C6:  IORWF  F82,F
....................          delay_ms(95); 
05C8:  MOVLW  5F
05CA:  MOVWF  xE6
05CC:  RCALL  00DC
....................          lcd_putc("\f"); 
05CE:  MOVLW  A4
05D0:  MOVWF  FF6
05D2:  MOVLW  00
05D4:  MOVWF  FF7
05D6:  RCALL  028A
....................          bit_clear(PORTC, luz); 
05D8:  MOVLW  01
05DA:  MOVWF  00
05DC:  MOVF   xDE,W
05DE:  MOVWF  01
05E0:  BZ    05EA
05E2:  BCF    FD8.0
05E4:  RLCF   00,F
05E6:  DECFSZ 01,F
05E8:  BRA    05E2
05EA:  MOVF   00,W
05EC:  XORLW  FF
05EE:  ANDWF  F82,F
....................          delay_ms(45); 
05F0:  MOVLW  2D
05F2:  MOVWF  xE6
05F4:  RCALL  00DC
....................       }else 
05F6:  BRA    0602
....................       { 
....................          lcd_putc("\f"); 
05F8:  MOVLW  A6
05FA:  MOVWF  FF6
05FC:  MOVLW  00
05FE:  MOVWF  FF7
0600:  RCALL  028A
....................       } 
0602:  INCF   xE0,F
0604:  BRA    0588
....................    }   
....................     
....................    if(luz == 0 || luz == 1 || luz == 2) 
0606:  MOVF   xDE,F
0608:  BZ    0616
060A:  DECFSZ xDE,W
060C:  BRA    0610
060E:  BRA    0616
0610:  MOVF   xDE,W
0612:  SUBLW  02
0614:  BNZ   0630
....................    { 
....................       if(establecer) 
0616:  MOVF   xDF,F
0618:  BZ    0630
....................       { 
....................          bit_set(PORTC, luz); 
061A:  MOVLW  01
061C:  MOVWF  00
061E:  MOVF   xDE,W
0620:  MOVWF  01
0622:  BZ    062C
0624:  BCF    FD8.0
0626:  RLCF   00,F
0628:  DECFSZ 01,F
062A:  BRA    0624
062C:  MOVF   00,W
062E:  IORWF  F82,F
....................       } 
....................    } 
0630:  RETURN 0
.................... } 
....................  
.................... //funciones sin cambios significatios 
....................  
.................... /** 
....................    inicializa un arreglo con el valor proporcionado 
.................... **/ 
.................... void inicializar(char cadena[], int longitud, char valor) 
.................... { 
....................    for(int a = 0; a < longitud; a++) 
*
00BC:  CLRF   xDE
00BE:  MOVF   xDC,W
00C0:  SUBWF  xDE,W
00C2:  BC    00DA
....................    { 
....................       cadena[a] = valor; 
00C4:  CLRF   03
00C6:  MOVF   xDE,W
00C8:  ADDWF  xDA,W
00CA:  MOVWF  FE9
00CC:  MOVF   xDB,W
00CE:  ADDWFC 03,W
00D0:  MOVWF  FEA
00D2:  MOVFF  DD,FEF
00D6:  INCF   xDE,F
00D8:  BRA    00BE
....................    } 
00DA:  RETURN 0
.................... } 
....................  
.................... /** 
....................    muestra la pantalla de inicializacion 
.................... **/ 
.................... void cargando() 
.................... { 
....................    lcd_init(); 
*
02AA:  BRA    01A0
....................    lcd_gotoxy(5,1); 
02AC:  MOVLW  05
02AE:  MOVWF  xE6
02B0:  MOVLW  01
02B2:  MOVWF  xE7
02B4:  RCALL  0218
....................    lcd_putc("INICIANDO"); 
02B6:  MOVLW  A8
02B8:  MOVWF  FF6
02BA:  MOVLW  00
02BC:  MOVWF  FF7
02BE:  RCALL  028A
....................    for(int i = 1; i < 17; ) 
02C0:  MOVLW  01
02C2:  MOVWF  xCC
02C4:  MOVF   xCC,W
02C6:  SUBLW  10
02C8:  BNC   032E
....................    { 
....................       for(int j = 0; j < 3; j++) 
02CA:  CLRF   xCD
02CC:  MOVF   xCD,W
02CE:  SUBLW  02
02D0:  BNC   032C
....................       { 
....................          lcd_gotoxy(i++,2);  
02D2:  MOVF   xCC,W
02D4:  INCF   xCC,F
02D6:  MOVWF  xCE
02D8:  MOVWF  xE6
02DA:  MOVLW  02
02DC:  MOVWF  xE7
02DE:  RCALL  0218
....................          lcd_putc((unsigned char)255); 
02E0:  SETF   xE5
02E2:  RCALL  023A
....................          bit_set(PORTC, 2 - j); 
02E4:  MOVLW  02
02E6:  BSF    FD8.0
02E8:  SUBFWB xCD,W
02EA:  MOVWF  xCE
02EC:  MOVLW  01
02EE:  MOVWF  00
02F0:  MOVF   xCE,W
02F2:  MOVWF  01
02F4:  BZ    02FE
02F6:  BCF    FD8.0
02F8:  RLCF   00,F
02FA:  DECFSZ 01,F
02FC:  BRA    02F6
02FE:  MOVF   00,W
0300:  IORWF  F82,F
....................          delay_ms(30); 
0302:  MOVLW  1E
0304:  MOVWF  xE6
0306:  RCALL  00DC
....................          bit_clear(PORTC, 2- j); 
0308:  MOVLW  02
030A:  BSF    FD8.0
030C:  SUBFWB xCD,W
030E:  MOVWF  xCE
0310:  MOVLW  01
0312:  MOVWF  00
0314:  MOVF   xCE,W
0316:  MOVWF  01
0318:  BZ    0322
031A:  BCF    FD8.0
031C:  RLCF   00,F
031E:  DECFSZ 01,F
0320:  BRA    031A
0322:  MOVF   00,W
0324:  XORLW  FF
0326:  ANDWF  F82,F
0328:  INCF   xCD,F
032A:  BRA    02CC
....................       } 
032C:  BRA    02C4
....................    } 
....................    lcd_putc("\f"); 
032E:  MOVLW  B2
0330:  MOVWF  FF6
0332:  MOVLW  00
0334:  MOVWF  FF7
0336:  RCALL  028A
0338:  GOTO   0A32 (RETURN)
.................... } 
....................  
.................... /** 
....................    retorna la tecla presiona 
....................    si no se presiona ninguna retorna 0 
.................... **/ 
.................... char com_tecla() 
*
0360:  CLRF   xE3
.................... { 
....................    const int FILA = 4; 
....................    const int COLUMNA = 4; 
....................    char const KEYS[4][4] = {  
....................                              {'1','2','3','A'}, 
....................                              {'4','5','6','B'}, 
....................                              {'7','8','9','C'}, 
....................                              {'*','0','#','D'} 
....................                            }; 
....................    char tecla = 0; 
....................     
....................    TRISB=0xF0; 
0362:  MOVLW  F0
0364:  MOVWF  F93
....................    PORTB=0x00; 
0366:  CLRF   F81
....................     
....................    for(int i = 0; i < FILA; i++) 
0368:  CLRF   xE4
036A:  MOVF   xE4,W
036C:  SUBLW  03
036E:  BNC   03FC
....................    { 
....................       bit_set(PORTB, i); 
0370:  MOVLW  01
0372:  MOVWF  00
0374:  MOVF   xE4,W
0376:  MOVWF  01
0378:  BZ    0382
037A:  BCF    FD8.0
037C:  RLCF   00,F
037E:  DECFSZ 01,F
0380:  BRA    037A
0382:  MOVF   00,W
0384:  IORWF  F81,F
....................       for(int j = 0; j < COLUMNA; j++) 
0386:  CLRF   xE5
0388:  MOVF   xE5,W
038A:  SUBLW  03
038C:  BNC   03E0
....................       { 
....................          if(bit_test(portb,j + COLUMNA) == 1) 
038E:  MOVLW  04
0390:  ADDWF  xE5,W
0392:  MOVWF  xE6
0394:  MOVFF  F81,00
0398:  MOVF   xE6,W
039A:  MOVWF  01
039C:  BZ    03A6
039E:  BCF    FD8.0
03A0:  RRCF   00,F
03A2:  DECFSZ 01,F
03A4:  BRA    039E
03A6:  BTFSS  00.0
03A8:  BRA    03DC
....................          { 
....................             tecla=KEYS[i][j];           
03AA:  MOVF   xE4,W
03AC:  MULLW  04
03AE:  MOVF   FF3,W
03B0:  CLRF   xE7
03B2:  MOVWF  xE6
03B4:  CLRF   03
03B6:  MOVF   xE5,W
03B8:  ADDWF  xE6,W
03BA:  MOVWF  01
03BC:  MOVF   xE7,W
03BE:  ADDWFC 03,F
03C0:  MOVF   01,W
03C2:  MOVFF  FF2,E6
03C6:  BCF    FF2.7
03C8:  RCALL  0004
03CA:  BTFSC  xE6.7
03CC:  BSF    FF2.7
03CE:  MOVWF  xE3
....................             delay_ms(45);   
03D0:  MOVLW  2D
03D2:  MOVWF  xE6
03D4:  RCALL  00DC
....................             return tecla; 
03D6:  MOVFF  E3,01
03DA:  BRA    0400
....................          } 
03DC:  INCF   xE5,F
03DE:  BRA    0388
....................       } 
....................       bit_clear(PORTB, i); 
03E0:  MOVLW  01
03E2:  MOVWF  00
03E4:  MOVF   xE4,W
03E6:  MOVWF  01
03E8:  BZ    03F2
03EA:  BCF    FD8.0
03EC:  RLCF   00,F
03EE:  DECFSZ 01,F
03F0:  BRA    03EA
03F2:  MOVF   00,W
03F4:  XORLW  FF
03F6:  ANDWF  F81,F
03F8:  INCF   xE4,F
03FA:  BRA    036A
....................    } 
....................    return tecla; 
03FC:  MOVFF  E3,01
0400:  RETURN 0
.................... } 
....................  
.................... // efecto de cursor parpadiante 
.................... int comando_tecla() 
0402:  CLRF   xE0
.................... { 
....................    char tecla = 0; 
....................    lcd_putc((unsigned char)255); 
0404:  SETF   xE5
0406:  RCALL  023A
....................    for(int i = 0; i < 6; i++) 
0408:  CLRF   xE1
040A:  MOVF   xE1,W
040C:  SUBLW  05
040E:  BNC   0434
....................    { 
....................       delay_ms(10); 
0410:  MOVLW  0A
0412:  MOVWF  xE6
0414:  RCALL  00DC
....................       tecla = com_tecla(); 
0416:  RCALL  0360
0418:  MOVFF  01,E0
....................       if(tecla) 
041C:  MOVF   xE0,F
041E:  BZ    0430
....................       { 
....................          lcd_putc("\b \b"); 
0420:  MOVLW  B4
0422:  MOVWF  FF6
0424:  MOVLW  00
0426:  MOVWF  FF7
0428:  RCALL  028A
....................          return tecla; 
042A:  MOVFF  E0,01
042E:  BRA    0464
....................       } 
0430:  INCF   xE1,F
0432:  BRA    040A
....................    } 
....................    lcd_putc("\b \b"); 
0434:  MOVLW  B8
0436:  MOVWF  FF6
0438:  MOVLW  00
043A:  MOVWF  FF7
043C:  RCALL  028A
....................    for(int j = 0; j < 6; j++) 
043E:  CLRF   xE2
0440:  MOVF   xE2,W
0442:  SUBLW  05
0444:  BNC   0460
....................    { 
....................       delay_ms(10); 
0446:  MOVLW  0A
0448:  MOVWF  xE6
044A:  RCALL  00DC
....................       tecla = com_tecla(); 
044C:  RCALL  0360
044E:  MOVFF  01,E0
....................       if(tecla) 
0452:  MOVF   xE0,F
0454:  BZ    045C
....................       { 
....................          return tecla; 
0456:  MOVFF  E0,01
045A:  BRA    0464
....................       } 
045C:  INCF   xE2,F
045E:  BRA    0440
....................    } 
....................    return tecla;      
0460:  MOVFF  E0,01
0464:  RETURN 0
.................... } 
....................  

Configuration Fuses:
   Word  1: C83F   PLL12 CPUDIV4 USBDIV INTRC_IO FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
